# API Routes for Complex Vulnerability Scenarios
# Multiple entry points leading to the same vulnerable sinks

from flask import Flask, request, jsonify, session
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

try:
    from services.extended_services import (
        UserProfileService, 
        OrderManagementService, 
        AdminManagementService,
        BackgroundSyncService
    )
except ImportError:
    # Fallback for testing
    UserProfileService = None
    OrderManagementService = None
    AdminManagementService = None
    BackgroundSyncService = None

app = Flask(__name__)

class VulnerabilityRoutes:
    """Routes that demonstrate complex attack paths"""
    
    def __init__(self):
        self.profile_service = UserProfileService()
        self.order_service = OrderManagementService() 
        self.admin_service = AdminManagementService()
        self.sync_service = BackgroundSyncService()

    # ENTRY POINT 1: Profile Update API - VULNERABLE
    def profile_update_endpoint(self):
        """Public API for profile updates"""
        username = request.json.get('username', '')
        email = request.json.get('email', '')
        
        if not username:
            return jsonify({"error": "Username required"}), 400
            
        # ATTACK PATH: entry_profile_api -> transport_user_service -> sink_template_injection
        result = self.profile_service.update_profile(username, email)
        
        # VULNERABILITY: Template injection in response
        welcome_template = f"<h1>Welcome {username}!</h1><p>Profile updated with email: {email}</p>"
        from flask import render_template_string
        return render_template_string(welcome_template)
    
    # ENTRY POINT 2: Order Creation API - VULNERABLE  
    def order_create_endpoint(self):
        """Internal API for order creation"""
        product_id = request.json.get('product_id', '')
        user_id = request.json.get('user_id', '')
        quantity = request.json.get('quantity', 1)
        
        # ATTACK PATH: entry_order_api -> transport_order_service -> sink_file_write
        result = self.order_service.create_order(product_id, user_id, quantity)
        
        # VULNERABILITY: File write vulnerability
        order_details = f"Order created: Product {product_id} for user {user_id}"
        file_path = f"/tmp/orders/{user_id}_order.txt"
        with open(file_path, 'w') as f:
            f.write(order_details)
            
        return jsonify(result)
    
    # ENTRY POINT 3: Admin User Deletion - PARTIALLY SECURE
    def admin_delete_endpoint(self):
        """Admin endpoint for user deletion"""
        admin_user = request.headers.get('X-Admin-User', 'unknown')
        target_user = request.json.get('target_username', '')
        
        if not target_user:
            return jsonify({"error": "Target username required"}), 400
            
        # ATTACK PATH: entry_admin_panel -> transport_admin_service -> security_wrapper -> transport_central_logger -> sink_log_writer
        result = self.admin_service.delete_user(admin_user, target_user)
        return jsonify(result)
    
    # ENTRY POINT 4: Background Job Trigger - VULNERABLE
    def background_sync_endpoint(self):
        """Endpoint to trigger background processing"""
        order_queue = request.json.get('orders', [])
        
        # ATTACK PATH: entry_background_job -> transport_order_service -> transport_central_logger -> sink_log_writer
        result = self.sync_service.process_nightly_sync(order_queue)
        return jsonify(result)

# Flask route bindings
vulnerability_routes = VulnerabilityRoutes()

@app.route('/api/profile/update', methods=['POST'])
def api_profile_update():
    return vulnerability_routes.profile_update_endpoint()

@app.route('/api/orders/new', methods=['POST']) 
def api_order_create():
    return vulnerability_routes.order_create_endpoint()

@app.route('/admin/delete_user', methods=['POST'])
def admin_delete_user():
    return vulnerability_routes.admin_delete_endpoint()

@app.route('/jobs/nightly_sync', methods=['POST'])
def background_nightly_sync():
    return vulnerability_routes.background_sync_endpoint()


# ==================== ADDITIONAL XSS AND TEMPLATE INJECTION ROUTES ====================

@app.route('/dashboard')
def dashboard():
    """CRITICAL: Template injection vulnerability"""
    name = request.args.get('name', 'Guest')
    # Template injection vulnerability - directly embedding user input
    template = f'''
    <div class="header">
        <h1>Welcome, {name}!</h1>
    </div>
    <div class="content">
        <p>Your dashboard content goes here.</p>
    </div>
    '''
    from flask import render_template_string
    return render_template_string(template)

@app.route('/search')
def search_page():
    """CRITICAL: XSS vulnerability - unescaped user input"""
    search_query = request.args.get('q', '')
    # Direct embedding of user input without escaping
    html_content = f"<h1>Search results for: {search_query}</h1>"
    from flask import render_template_string
    return render_template_string(html_content)

@app.route('/comment')
def user_comment():
    """CRITICAL: XSS vulnerability in comment display"""
    comment = request.args.get('comment', '')
    # No HTML escaping
    response_html = f'''
    <div class="comment-section">
        <h2>User Comment</h2>
        <div class="comment-body">{comment}</div>
    </div>
    '''
    from flask import render_template_string
    return render_template_string(response_html)

@app.route('/user_profile')
def user_profile_xss():
    """GOOD TO FIX: XSS vulnerability - authenticated users only, limited impact"""
    from flask import session
    profile_data = request.args.get('bio', '')
    user_id = session.get('user_id', 'guest')
    
    # XSS vulnerability but requires authentication
    html_response = f"""
    <div class="profile">
        <h2>User Profile - {user_id}</h2>
        <p>Bio: {profile_data}</p>
    </div>
    """
    from flask import render_template_string
    return render_template_string(html_response)

@app.route('/notification')
def notification_display():
    """CRITICAL: XSS in notification system"""
    message = request.args.get('msg', '')
    notification_type = request.args.get('type', 'info')
    
    # User-controlled content in HTML
    html = f'''
    <div class="notification {notification_type}">
        <span class="icon">!</span>
        <span class="message">{message}</span>
    </div>
    '''
    from flask import render_template_string
    return render_template_string(html)

@app.route('/render_sanitized')
def render_with_escaping():
    """PROTECTED: XSS vulnerability - but properly sanitized"""
    import html
    user_comment = request.args.get('comment', '')
    safe_comment = html.escape(user_comment, quote=True)
    template = f"<div>User said: {safe_comment}</div>"
    from flask import render_template_string
    return render_template_string(template)

@app.route('/rate_limited_endpoint')
def rate_limited_search():
    """GOOD TO FIX: XSS vulnerability - but protected by WAF and rate limiting"""
    search_query = request.args.get('q', '')
    # XSS but with external protections (WAF, rate limiting)
    html_content = f"<h1>Search results for: {search_query}</h1>"
    from flask import render_template_string
    return render_template_string(html_content)


# ==================== COMMAND INJECTION ROUTES ====================

@app.route('/ping', methods=['POST'])
def ping_endpoint():
    """CRITICAL: Command injection vulnerability"""
    host = request.form.get('host', '')
    # Command injection through subprocess
    import subprocess
    result = subprocess.check_output(f"ping -c 1 {host}", shell=True)
    return result.decode()

@app.route('/direct_command', methods=['POST'])
def direct_command_injection():
    """CRITICAL: Command injection - no protections"""
    import subprocess
    user_cmd = request.args.get('cmd', '')
    
    # Direct command execution
    result = subprocess.run(user_cmd, shell=True, capture_output=True, text=True)
    
    return jsonify({
        "command": user_cmd,
        "output": result.stdout,
        "error": result.stderr,
        "return_code": result.returncode
    })

@app.route('/admin_debug')
def admin_debug_function():
    """GOOD TO FIX: Command injection - but protected by admin-only access"""
    # NOTE: In production, this would have @staff_member_required decorator
    import subprocess
    debug_cmd = request.args.get('cmd', '')
    result = subprocess.run(debug_cmd, shell=True, capture_output=True, text=True)
    return jsonify({"output": result.stdout, "error": result.stderr})


# ==================== FILE ACCESS ROUTES ====================

@app.route('/file')
def get_file():
    """GOOD TO FIX: Path traversal with weak validation"""
    from services.extended_services import FileOperationsService
    file_service = FileOperationsService()
    
    filename = request.args.get('name', '')
    content = file_service.read_user_file(filename)
    
    if content:
        return content
    else:
        return "File not found or access denied"

@app.route('/upload_and_execute', methods=['POST'])
def file_upload_rce():
    """CRITICAL: Path traversal + RCE vulnerability"""
    from services.extended_services import FileOperationsService
    file_service = FileOperationsService()
    
    filename = request.args.get('filename', '')
    content = request.args.get('content', '')
    
    # Direct file write with user-controlled path
    result = file_service.upload_and_save_file(filename, content)
    return jsonify({"result": result})

@app.route('/file_access_sanitized')
def file_access_with_validation():
    """PROTECTED: Path traversal - but with proper validation"""
    import os
    filename = request.args.get('file', '')
    
    # Proper validation
    if not filename or '..' in filename or filename.startswith('/'):
        return "Invalid filename", 400
    
    safe_filename = os.path.basename(filename)
    allowed_extensions = ['.txt', '.pdf', '.jpg']
    
    if not any(safe_filename.endswith(ext) for ext in allowed_extensions):
        return "File type not allowed", 400
    
    file_path = os.path.join('/safe/uploads/', safe_filename)
    
    try:
        with open(file_path, 'r') as f:
            return f.read()
    except FileNotFoundError:
        return "File not found", 404


# ==================== SQL INJECTION ROUTES ====================

@app.route('/public_search')
def public_search_vulnerable():
    """CRITICAL: SQL injection - immediately exploitable"""
    from repos.invoice_repo import search_invoices_vulnerable
    
    search_term = request.args.get('q', '')
    results = search_invoices_vulnerable(search_term)
    
    return jsonify({"results": results})

@app.route('/search_sanitized')
def search_with_parameterized_query():
    """PROTECTED: SQL injection - but properly sanitized with parameterized query"""
    from repos.invoice_repo import search_with_parameterized_query
    
    search_term = request.args.get('q', '')
    results = search_with_parameterized_query(search_term)
    
    return jsonify({"results": results})

@app.route('/log_search')
def log_search_sqli():
    """GOOD TO FIX: SQL injection in logging system - lower business impact"""
    from repos.invoice_repo import search_logs_sqli
    
    search_term = request.args.get('term', '')
    logs = search_logs_sqli(search_term)
    
    return jsonify({"logs": logs})


# ==================== AUTHENTICATION ROUTES ====================

@app.route('/login', methods=['POST'])
def login():
    """GOOD TO FIX: Vulnerable authentication with SQL injection"""
    from repos.invoice_repo import authenticate_user
    
    username = request.form.get('username', '')
    password = request.form.get('password', '')
    
    # Using the vulnerable authentication function
    user = authenticate_user(username, password)
    
    if user:
        return jsonify({"message": f"Welcome, {user[1]}!"})
    else:
        return jsonify({"error": "Invalid credentials"}), 401

@app.route('/register', methods=['POST'])
def register():
    """GOOD TO FIX: Weak validation and password hashing"""
    from services.extended_services import AuthenticationService
    import sqlite3
    
    auth_service = AuthenticationService()
    
    username = request.form.get('username', '')
    password = request.form.get('password', '')
    email = request.form.get('email', '')
    
    # Using the vulnerable validation function
    if not auth_service.validate_email(email):
        return jsonify({"error": "Invalid email format"}), 400
    
    # Using the vulnerable password hashing
    hashed_password = auth_service.hash_password(password)
    
    try:
        conn = sqlite3.connect('users.db')
        c = conn.cursor()
        c.execute("INSERT INTO users (username, password, role) VALUES (?, ?, ?)",
                  (username, hashed_password, 'user'))
        conn.commit()
        conn.close()
        
        return jsonify({"message": "Registration successful"})
    except Exception as e:
        return jsonify({"error": str(e)}), 500
